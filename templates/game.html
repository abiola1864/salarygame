<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/axios@0.27.2/dist/axios.min.js"></script>
    <title>Life Choices Game</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">

</head>
<body>
    <div class="game-container">
        <div class="stage-indicator">
            <div class="stage-dot" data-stage="baseline"></div>
            <div class="stage-dot" data-stage="description_page_condition_a"></div>
            <div class="stage-dot" data-stage="condition_a"></div>
            <div class="stage-dot" data-stage="condition_a_additionalpayment"></div>
            <div class="stage-dot" data-stage="description_page_condition_b"></div>
            <div class="stage-dot" data-stage="condition_b"></div>
            <div class="stage-dot" data-stage="condition_b_bonus"></div>
            <div class="stage-dot" data-stage="condition_c"></div>
            <div class="stage-dot" data-stage="congratulations"></div>
        </div>
        <div id="scenario" class="scenario">
            <h2 id="scenario-title"></h2>
            <p id="scenario-description"></p>
            <div id="unexpected-expense" class="unexpected-expense" style="display: none;"></div>
        </div>

     

        <div id="shock-guidance" class="guidance-message-container"></div>
     <div id="shockEvent" class="shock-container">
            <div class="shock-content">
                <h2>Life Happens! ðŸ˜®</h2>
                <p>Click one box to reveal your financial challenge...</p>
                
                <div class="shock-boxes">
                    <div class="shock-box" onclick="revealShock(this, 0)">
                        <span>?</span>
                    </div>
                    <div class="shock-box" onclick="revealShock(this, 1)">
                        <span>?</span>
                    </div>
                    <div class="shock-box" onclick="revealShock(this, 2)">
                        <span>?</span>
                    </div>
                </div>
                
                <button id="continueButton" style="display: none;" onclick="continueGame()">
                    Continue Game
                </button>
            </div>
        </div>

<!-- 
        <button onclick="showStageData('baseline')">Show Data for Baseline</button>
<button onclick="showAllStagesData()">Show Data for All Stages</button>
<button onclick="clearAllGameData()">Clear All Game Data</button> -->

<script>
    function clearAllGameData() {
        clearGameData();
        clearLocalStorage();
        alert("All game data has been cleared!");
    }
</script>






        <!-- Split View for Condition B -->
        <div id="split-view" class="split-view" style="display: none;">
            <!-- Regular Salary Section -->
            <div class="split-section">
                <div class="split-header">Regular Salary (10,000 NGN)</div>
                <div class="mini-progress-stats">
                    <div>Spent: <span id="salary-spent">0 NGN</span></div>
                    <div class="mini-progress">
                        <div id="salary-progress" class="mini-progress-fill"></div>
                    </div>
                    <div>Remaining: <span id="salary-remaining">10,000 NGN</span></div>
                </div>
                <div id="salary-allocations"></div>
            </div>

    




            <!-- Bonus Section -->
            <div class="split-section">
                <div class="split-header">Meal Bonus (5,000 NGN)</div>
                <div class="mini-progress-stats">
                    <div>Spent: <span id="bonus-spent">0 NGN</span></div>
                    <div class="mini-progress">
                        <div id="bonus-progress" class="mini-progress-fill"></div>
                    </div>
                    <div>Remaining: <span id="bonus-remaining">5,000 NGN</span></div>
                </div>
                <div id="bonus-allocations"></div>
            </div>
        </div>

        <!-- Regular View -->
        <div id="regular-view">
            <div class="progress-container">
                <div class="progress-stats">
                    <div class="stat-box">
                        <div>Available</div>
                        <strong id="available-amount">0 NGN</strong>
                    </div>
                    <div class="stat-box">
                        <div>Spent</div>
                        <strong id="spent-amount">0 NGN</strong>
                    </div>
                    <div class="stat-box">
                        <div>Remaining</div>
                        <strong id="remaining-amount">0 NGN</strong>
                    </div>
                </div>
                <div class="progress-bar">
                    <div id="progress" class="progress-fill"></div>
                </div>
            </div>

            <form id="allocation-form">
                <div class="allocation-grid">
                    <div class="category-section">
                        <div class="category-title">
                            <i class="fas fa-utensils"></i> Daily Needs
                        </div>
                        <div id="essentials-grid" class="item-grid"></div>
                    </div>
                    
                    <div class="category-section">
                        <div class="category-title">
                            <i class="fas fa-bus"></i> Transport
                        </div>
                        <div id="transport-grid" class="item-grid"></div>
                    </div>
                    
                    <div class="category-section">
                        <div class="category-title">
                            <i class="fas fa-smile"></i> Lifestyle
                        </div>
                        <div id="lifestyle-grid" class="item-grid"></div>
                    </div>
                    
                    <div class="category-section">
                        <div class="category-title">
                            <i class="fas fa-piggy-bank"></i> Savings
                        </div>
                        <div id="savings-grid" class="item-grid"></div>
                    </div>
                </div>
            </form>
        </div>

        <div class="controls-section">
            <button type="submit" id="submit-button">Submit Choices</button>
        </div>

        <div id="game-complete" class="game-complete">
            <h2>Congratulations!</h2>
            <p>You have completed all stages of the Life Choices Game.</p>
            <button onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <script>
        // const SPENDING_CATEGORIES = {
        //     essentials: {
        //         name: "Daily Needs",
        //         icon: "fas fa-utensils",
        //         items: [
        //             { name: "Food Stuffs", icon: "ðŸ²" },
        //             { name: "Groceries", icon: "ðŸ²" },
        //             { name: "School Fees", icon: "ðŸŽ“" },
        //             { name: "House Rent", icon: "ðŸ " },
        //             { name: "Electricity Bill (AECN)", icon: "âš¡" },
        //             { name: "Water Bill", icon: "ðŸ’§" },
        //             { name: "Medical Bills", icon: "ðŸ’Š" },
        //             { name: "Transportation to Work", icon: "ðŸšŒ" },
        //             { name: "Mobile Data/Internet", icon: "ðŸ“¶" },
        //             { name: "Cleaning Supplies", icon: "ðŸ§¼" },
        //             { name: "Childcare Supplies", icon: "ðŸ“š" },
        //             { name: "Clothing and Footwear", icon: "ðŸ‘—" },
        //             { name: "Cooking Gas", icon: "â›½" },
        //             { name: "Laundry Services", icon: "ðŸ§º" },
        //             { name: "Security Fees", icon: "ðŸ”’" },
        //             { name: "House Maintenance", icon: "ðŸ”§" },
        //             { name: "Spiritual/Tithe Donations", icon: "â›ª" }
        //         ]
        //     },
        //     transport: {
        //         name: "Transport",
        //         icon: "fas fa-bus",
        //         items: [
        //             { name: "Okada", icon: "ðŸï¸" },
        //             { name: "Uber/Bolt", icon: "ðŸš—" },
        //             { name: "Generator Fuel", icon: "â›½" },
        //             { name: "Car Fuel", icon: "ðŸš—" },
        //             { name: "Bus Fare", icon: "ðŸšŒ" },
        //             { name: "Taxi", icon: "ðŸš–" }
        //         ]
        //     },
        //     lifestyle: {
        //         name: "Lifestyle",
        //         icon: "fas fa-smile",
        //         items: [
        //             { name: "Cinema Visit", icon: "ðŸŽ¬" },
        //             { name: "Suya Night", icon: "ðŸ¥©" },
        //             { name: "Concert Tickets", icon: "ðŸŽ¶" },
        //             { name: "Shopping Spree", icon: "ðŸ›ï¸" },
        //             { name: "Vacations", icon: "âœˆï¸" },
        //             { name: "Spa Day", icon: "ðŸ’†â€â™€ï¸" },
        //             // { name: "Gourmet Dinner", icon: "ðŸ½ï¸" },
        //             { name: "Gaming Subscription", icon: "ðŸŽ®" },
        //             { name: "Designer Clothes", icon: "ðŸ‘—" },
        //             { name: "Sports Event Tickets", icon: "ðŸŸï¸" },
        //             { name: "Streaming Subscription", icon: "ðŸ“º" },
        //             { name: "Art Gallery Visit", icon: "ðŸ–¼ï¸" }
        //         ]
        //     },
        //     savings: {
        //         name: "Savings",
        //         icon: "fas fa-piggy-bank",
        //         items: [
        //             { name: "Bank Deposit", icon: "ðŸ¦" },
        //             { name: "Emergency Fund", icon: "ðŸ”’" },
        //             { name: "Investment", icon: "ðŸ“ˆ" },
        //             { name: "Debt Repayment", icon: "ðŸ’³" },
        //             { name: "Cooperative Saving", icon: "ðŸ¤" },
        //             { name: "Forex Savings", icon: "ðŸ’µ" },
        //             { name: "Education Fund", icon: "ðŸŽ“" }
        //         ]
        //     }
        // };



        const SPENDING_CATEGORIES = {
            essentials: {
                name: "Daily Needs",
                icon: "ðŸ›ï¸",
                items: [
                    { name: "Food Stuffs", icon: "ðŸ²" },
                    { name: "Groceries", icon: "ðŸ²" },
                    { name: "Clothing", icon: "ðŸ‘•" },
                    { name: "Childcare Expenses", icon: "ðŸ¼" },
                    { name: "School Fees", icon: "ðŸŽ“" },
                    { name: "Internet Subscription", icon: "ðŸŒ" },
                    { name: "House Rent", icon: "ðŸ " },
                    { name: "Generator Fuel", icon: "â›½" },
                    { name: "Bills (Electricity and Water etc)", icon: "âš¡" }
                ]
            },
            transport: {
                name: "Transport",
                icon: "ðŸšŒ",
                items: [
                    { name: "Okada", icon: "ðŸï¸" },
                    { name: "Uber/Bolt", icon: "ðŸš—" },
                    { name: "Keke Napep", icon: "ðŸ›º" },
                    { name: "Generator Fuel", icon: "â›½" },
                    { name: "Car Fuel", icon: "ðŸš—" },
                    { name: "Bus Fare", icon: "ðŸšŒ" },
                    { name: "Taxi", icon: "ðŸš–" }
                ]
            },
            lifestyle: {
                name: "Lifestyle",
                icon: "ðŸ˜Š",
                items: [
                    { name: "Cinema", icon: "ðŸŽ¬" },
                    { name: "Suya Night", icon: "ðŸ¥©" },
                    { name: "Concert", icon: "ðŸŽ¶" },
                    { name: "Shopping", icon: "ðŸ›ï¸" },
                    { name: "Vacation", icon: "âœˆï¸" },
                    { name: "Weddings/Parties", icon: "ðŸŽ‰" },
                    { name: "Social Club Membership", icon: "ðŸ¤" },
                    { name: "Hobbies (e.g., painting)", icon: "ðŸŽ¨" },
                    { name: "Spa Day", icon: "ðŸ’†â€â™€ï¸" }
                ]
            },
            savings: {
                name: "Savings",
                icon: "ðŸ’°",
                items: [
            { name: "Bank Deposit", icon: "ðŸ¦" },
            { name: "Emergency Fund", icon: "ðŸ”’" },
            { name: "Investment", icon: "ðŸ“ˆ" },
            { name: "Debt Repayment", icon: "ðŸ’³" },
            { name: "Education Fund", icon: "ðŸŽ“" },
            { name: "Cooperative Contribution", icon: "ðŸ¤" },
            { name: "Ajo/Esusu Savings", icon: "ðŸ’¸" },
            { name: "Real Estate Savings", icon: "ðŸ˜ï¸" },
            { name: "Insurance Premiums", icon: "ðŸ›¡ï¸" },
            { name: "Family Support Contributions", icon: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦" }
        ]
            }
        };




        // Modified STAGES object to include proper condition_b1 handling and post-shock descriptions






// Function to update scenario description after shock event
function updateScenarioAfterShock() {
    const stage = STAGES[currentStage];
    const currentStageData = stageData[currentStage];
    
    if (currentStageData && currentStageData.shockApplied) {
        const shockEvent = selectedEvents.find(event => event.amount === shockAmount);
        if (shockEvent) {
            // Update the scenario description with the post-shock description
            document.getElementById('scenario-description').innerHTML = 
                stage.getPostShockDescription(shockEvent, shockAmount);
        }
    }
}




// Define base salaries for different levels
const SALARY_LEVELS = {
    'high': 300000,
    'mid': 200000,
    'low': 100000
};

// Function to get base salary from localStorage
function getBaseSalary() {
    const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    return SALARY_LEVELS[userInfo.level || 'low']; // Default to low if level not found
}

// Function to calculate stage salary based on percentage of base salary
function calculateStageSalary(percentage) {
    const baseSalary = getBaseSalary();
    return Math.round(baseSalary * (percentage / 100));
}



// Salary progression tracker
const SALARY_PROGRESSION = {
    baseline: getBaseSalary(), // Initial N110,000

    march: {
        regular: getBaseSalary(), // Base N110,000
        additional: Math.round(getBaseSalary() * 0.1), // N11,000
        get total() { return this.regular + this.additional; } // N121,000 total
    },

    july: {
        // Now 1.5x based on March's total (N121,000)
        get regular() {
            const marchTotal = SALARY_PROGRESSION.march.total;
            return Math.round(marchTotal * 1); // ~N181,500
        },
        // Bonus based on new total
        get bonus() {
            const marchTotal = SALARY_PROGRESSION.march.total;
            return Math.round(marchTotal * 0.2); // ~N24,200
        },
        get total() { return this.regular + this.bonus; } // ~N205,700
    },

    final: {
        // 2.5x based on July's total (N205,700)
        get amount() {
            const julyTotal = SALARY_PROGRESSION.july.total;
            return Math.round(julyTotal * 2.5); // ~N514,250
        }
    }
};



const STAGES = {
    'baseline': {
        title: 'ðŸ“Š January 2025',
        description: function() {
            const salary = SALARY_PROGRESSION.baseline.toLocaleString();
            return `Welcome to January, my guy! ðŸŒŸ You've just received your â‚¦${salary} salary. Time to make it work! ðŸ˜… You know the drill â€” it's your regular monthly hustle. Sometimes, you'll need to stretch it like chewing gum! ðŸ˜œ Maybe skip that extra portion of suya or take the okada instead of the bus. Random "emergency" expenses will pop up, but for now, you've got â‚¦{salary} to work with! ðŸ’ª ðŸ’¸`;
        },
        getPostShockDescription: (shockEvent, shockAmount) => {
            const salary = SALARY_PROGRESSION.baseline;
            return `Chai! ðŸ˜© Life just threw you a curveball! ${shockEvent.text} That's â‚¦${shockAmount.toLocaleString()} gone from your budget!

Now your ${salary.toLocaleString()} NGN is looking more like ${(salary - shockAmount).toLocaleString()} NGN. Time to put on your financial ninja skills! ðŸ¥·

You'll need to adjust your budget to handle this surprise expense. Remember, every naira counts! Let's see how you navigate this challenge. ðŸ’ª`;
        },
        get base_salary() { return SALARY_PROGRESSION.baseline; },
        get shock_range() { 
            return [Math.round(this.base_salary * 0.05), Math.round(this.base_salary * 0.1)];
        },
        framing: 'regular'
    },

    'description_page_condition_a': {
        title: 'ðŸ’° March 2025 Preview',
        description: function() {
            const regular = SALARY_PROGRESSION.march.regular;
            const additional = SALARY_PROGRESSION.march.additional;
            const total = SALARY_PROGRESSION.march.total;
            return `Bam! It's March, and we're marching into MONEY! ðŸŽ‰

This month, you're not just getting your usual **${regular.toLocaleString()} NGN** salary. Oh no, you're getting an **extra ${additional.toLocaleString()} NGN**! That's a total of **${total.toLocaleString()} NGN** to juggle for the month. ðŸ¤‘

But before you start planning to buy everything on Jumia, let's talk. That **extra ${additional.toLocaleString()} NGN** is an **ADDITIONAL PAYMENT** to cushion the economic times! Just a little something from the powers that be to help you survive this month. ðŸ’ª

Now, don't get too excited o, it's **temporary**! We no sabi how long this extra cash will last. ðŸ™Œ So enjoy it while it's here, but stay grounded. Save some for emergencies â€” after all, your aunty can still send that "Emergency Alert" message anytime. ðŸ˜‚`;
        },
        isDescriptionPage: true
    },

    'condition_a': {
        title: 'ðŸ’¸ March 2025 - Regular Salary',
        description: function() {
            return `Time to manage your regular salary of ${SALARY_PROGRESSION.march.regular.toLocaleString()} NGN!`;
        },
        getPostShockDescription: (shockEvent, shockAmount) => {
            const regular = SALARY_PROGRESSION.march.regular;
            return `Eiya! ðŸ˜§ Life happened! ${shockEvent.text} That's â‚¦${shockAmount.toLocaleString()} gone from your regular salary!

Your ${regular.toLocaleString()} NGN salary is now ${(regular - shockAmount).toLocaleString()} NGN. Time to adjust your plans! ðŸ’ª

Show us how you handle this surprise expense. Every naira counts!`;
        },
        get base_salary() { return SALARY_PROGRESSION.march.regular; },
        get shock_range() {
            return [Math.round(this.base_salary * 0.05), Math.round(this.base_salary * 0.1)];
        },
        framing: 'regular'
    },

    'condition_a_additionalpayment': {
        title: 'ðŸ’¸ March 2025 - Additional Payment',
        description: function() {
            const additional = SALARY_PROGRESSION.march.additional;
            return `Now, let's manage your additional payment of ${additional.toLocaleString()} NGN!`;
        },
        getPostShockDescription: (shockEvent, shockAmount) => {
            const additional = SALARY_PROGRESSION.march.additional;
            return `Chai! ðŸ˜© Another surprise! ${shockEvent.text} That's â‚¦${shockAmount.toLocaleString()} from your additional payment!

Your ${additional.toLocaleString()} NGN additional payment is now ${(additional - shockAmount).toLocaleString()} NGN. Let's see how you handle this! ðŸ’ª

Time to show those money management skills!`;
        },
        get base_salary() { return SALARY_PROGRESSION.march.additional; },
        get shock_range() {
            return [Math.round(this.base_salary * 0.02), Math.round(this.base_salary * 0.05)];
        },
        framing: 'regular'
    },

    'description_page_condition_b': {
        title: 'ðŸŽ‰ Bonus Time Preview!',
        description: function() {
            const previousTotal = SALARY_PROGRESSION.march.total;
            const newRegular = SALARY_PROGRESSION.july.regular;
            const bonusAmount = SALARY_PROGRESSION.july.bonus;
            const total = SALARY_PROGRESSION.july.total;
            return `Bam, bam! Big win! ðŸŽ‰

Remember last month when you were managing **${previousTotal.toLocaleString()} NGN** in total? Well, things just got better! Your earnings is still **${newRegular.toLocaleString()} NGN**, AND you've got a special **meal bonus of ${bonusAmount.toLocaleString()} NGN**! 

That brings your total to **${total.toLocaleString()} NGN** for this month! ðŸ’°

It's a **meal bonus** just for you â€” a reward for all your hustle. Whether you decide to splurge on that special meal, clear bills, or stash it away for the rainy day, the choice is yours.

Enjoy the boost! ðŸ¤‘`;
        },
        isDescriptionPage: true,
        hasAnimation: true
    },

    'condition_b': {
        title: 'ðŸ’° July 2025 - Regular Salary',
        description: function() {
            const previousTotal = SALARY_PROGRESSION.march.total;
            const newRegular = SALARY_PROGRESSION.july.regular;
            return `Your earnings have increased! From managing a total of ${previousTotal.toLocaleString()} NGN before, now you've got ${newRegular.toLocaleString()} NGN to work with!`;
        },
        getPostShockDescription: (shockEvent, shockAmount) => {
            const regular = SALARY_PROGRESSION.july.regular;
            return `Ah ah! ðŸ˜« Life comes at you fast! ${shockEvent.text} That's â‚¦${shockAmount.toLocaleString()} from your earnings!

Your ${regular.toLocaleString()} NGN is now ${(regular - shockAmount).toLocaleString()} NGN. Time to readjust! ðŸ’ª

Show us how you handle unexpected expenses with your upgraded earnings!`;
        },
        get base_salary() { return SALARY_PROGRESSION.july.regular; },
        get shock_range() {
            return [Math.round(this.base_salary * 0.1), Math.round(this.base_salary * 0.15)];
        },
        framing: 'regular'
    },

    'condition_b_bonus': {
        title: 'ðŸ… July 2025 - Meal Bonus',
        description: function() {
            const bonusAmount = SALARY_PROGRESSION.july.bonus;
            return `Now, let's manage your special meal bonus of ${bonusAmount.toLocaleString()} NGN!`;
        },
        getPostShockDescription: (shockEvent, shockAmount) => {
            const bonus = SALARY_PROGRESSION.july.bonus;
            return `Ewo! ðŸ˜± Another surprise! ${shockEvent.text} That's â‚¦${shockAmount.toLocaleString()} from your meal bonus!

Your ${bonus.toLocaleString()} NGN bonus is now ${(bonus - shockAmount).toLocaleString()} NGN. Time to revise those plans!

Let's see how you handle this surprise with your bonus money! ðŸ’ª`;
        },
        get base_salary() { return SALARY_PROGRESSION.july.bonus; },
        get shock_range() {
            return [Math.round(this.base_salary * 0.05), Math.round(this.base_salary * 0.1)];
        },
        framing: 'regular'
    },

    'condition_b1': {
        title: 'ðŸ’° Lump Sum Salary and Bonus',
        description: function() {
            const total = SALARY_PROGRESSION.july.total;
            return `This month, your salary and bonus are combined into a lump sum of **${total.toLocaleString()} NGN**! ðŸŽ‰

You're no longer juggling separate payments â€” this is the full package: your increased earnings and bonus rolled into one. ðŸ’°

Enjoy the extra cushion, but be mindful of your spending! With this lump sum, you can still face surprises, so stay ready to adjust if life throws any unexpected expenses your way. 

But for now, it's time to manage your **${total.toLocaleString()} NGN** as one total. Keep your financial skills sharp! ðŸ’ª`;
        },
        getPostShockDescription: (shockEvent, shockAmount) => {
            const total = SALARY_PROGRESSION.july.total;
            return `Whoa! ðŸ˜® A surprise expense just hit! ${shockEvent.text} That's â‚¦${shockAmount.toLocaleString()} gone from your lump sum!

Now your **${total.toLocaleString()} NGN** is down to ${(total - shockAmount).toLocaleString()} NGN. Time to recalculate and adjust!

Can you still manage with less? Show us how you handle unexpected expenses with this combined amount! ðŸ’¸`;
        },
        get base_salary() { return SALARY_PROGRESSION.july.total; },
        get shock_range() {
            return [Math.round(this.base_salary * 0.1), Math.round(this.base_salary * 0.2)];
        },
        framing: 'lumpsum'
    },

    'condition_c': {
        title: 'ðŸ’° Salary Increase Stage',
        description: function() {
            const previousTotal = SALARY_PROGRESSION.july.total;
            const newTotal = SALARY_PROGRESSION.final.amount;
            const increase = newTotal - previousTotal;
            return `Hold on tight! ðŸŽ‰

Your financial journey has been amazing! From managing **${previousTotal.toLocaleString()} NGN** last time, you're now stepping up to **${newTotal.toLocaleString()} NGN**! That's an extra **${increase.toLocaleString()} NGN** to work with!

This isn't just a new salary â€” it's a reward for mastering your money management skills through all the ups and downs. You've learned to handle regular salaries, additional payments, bonuses, and even surprise expenses! ðŸ’ª

No more counting pennies or stretching the budget â€” you're officially living the good life! ðŸ’ƒ

Time to show off those premium money management skills and celebrate your **hard work** paying off. ðŸ˜Ž

Enjoy the boost, because you absolutely deserve it! ðŸ’¸`;
        },
        getPostShockDescription: (shockEvent, shockAmount) => {
            const total = SALARY_PROGRESSION.final.amount;
            return `Even big money needs careful management! ðŸ˜… ${shockEvent.text} That's â‚¦${shockAmount.toLocaleString()} you didn't plan for!

Your impressive ${total.toLocaleString()} NGN is now ${(total - shockAmount).toLocaleString()} NGN. Still substantial, but requires some tweaking!

Show us how you handle unexpected expenses with this upgraded lifestyle! ðŸŽ©`;
        },
        get base_salary() { return SALARY_PROGRESSION.final.amount; },
        get shock_range() {
            return [Math.round(this.base_salary * 0.1), Math.round(this.base_salary * 0.15)];
        },
        framing: 'salary-increase'
    },

    'congratulations': {
        title: 'ðŸŽ‰ Congratulations!',
        description: `You've successfully completed all the stages of the Life Choices Game! ðŸ†

Well done!`,
        base_salary: 0,
        isDescriptionPage: true,
        hasAnimation: true,
        framing: 'congratulations'
    }
};



// Function to update scenario description after shock event
function updateScenarioAfterShock() {
    const stage = STAGES[currentStage];
    const currentStageData = stageData[currentStage];
    
    if (currentStageData && currentStageData.shockApplied) {
        const shockEvent = selectedEvents.find(event => event.amount === shockAmount);
        if (shockEvent) {
            // Update the scenario description with the post-shock description
            document.getElementById('scenario-description').innerHTML = 
                stage.getPostShockDescription(shockEvent, shockAmount);
        }
    }
}
      
      

// Function to update scenario description after shock event
function updateScenarioAfterShock() {
    const stage = STAGES[currentStage];
    const currentStageData = stageData[currentStage];
    
    if (currentStageData && currentStageData.shockApplied) {
        const shockEvent = selectedEvents.find(event => event.amount === shockAmount);
        if (shockEvent) {
            // Update the scenario description with the post-shock description
            document.getElementById('scenario-description').innerHTML = 
                stage.getPostShockDescription(shockEvent, shockAmount);
        }
    }
}






let currentStage = 'baseline';
let totalAmount = 0;
let totalEarnings = 0;
let timerInterval;
let timeRemaining = 180; // 3 minutes in seconds

let selectedEvents = [];
let shockAmount = 0;
let stageData = {};

function startTimer() {
    timeRemaining = 180;
    clearInterval(timerInterval);
    
    timerInterval = setInterval(() => {
        timeRemaining--;
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        document.getElementById('timer').textContent = 
            `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        if (timeRemaining <= 0) {
            clearInterval(timerInterval);
            alert("Time's up! No speed bonus for this round.");
        }
    }, 1000);
}

function getRandomItems(category) {
    const selections = getStoredSelections();
    const selectedItems = selections[category] || [];
    
    // Map selected item names back to their full item objects
    return selectedItems
        .map(itemName => {
            return SPENDING_CATEGORIES[category].items.find(item => item.name === itemName);
        })
        .filter(item => item !== undefined) // Filter out any undefined items
        .slice(0, 2); // Ensure we only get 2 items even if more were selected
}




function createItemRow(item, categoryKey, prefix = '') {
    const div = document.createElement('div');
    div.className = 'item-row';
    div.innerHTML = `
        <div class="item-name">
            <span>${item.icon}</span>
            ${item.name}
        </div>
        <input type="number" 
               name="${prefix}${categoryKey}_${item.name.toLowerCase().replace(/\s+/g, '_')}"
               min="0" 
               oninput="updateAmount()"
               required>
    `;
    return div;
}






// function populateCategorySection(parentElement, categoryKey, prefix = '') {
//     const section = document.createElement('div');
//     section.className = 'category-section';
//     section.innerHTML = `
//         <div class="category-title">
//             <i class="${SPENDING_CATEGORIES[categoryKey].icon}"></i>
//             ${SPENDING_CATEGORIES[categoryKey].name}
//         </div>
//         <div class="item-grid">
//             ${getRandomItems(categoryKey, 2)
//                 .map(item => createItemRow(item, categoryKey, prefix).outerHTML)
//                 .join('')}
//         </div>
//     `;
//     parentElement.appendChild(section);
// }


function getStoredSelections() {
    const selections = localStorage.getItem('categorySelections');
    return selections ? JSON.parse(selections) : {};
}

// function getSelectedItems(category) {
//     const selections = getStoredSelections();
//     const selectedItems = selections[category] || [];
//     return selectedItems.map(itemName => {
//         return SPENDING_CATEGORIES[category].items.find(item => item.name === itemName);
//     }).filter(item => item);
// }





// function populateCategorySection(parentElement, categoryKey, prefix = '') {
//     const section = document.createElement('div');
//     section.className = 'category-section';
//     section.innerHTML = `
//         <div class="category-title">
//             <i class="${SPENDING_CATEGORIES[categoryKey].icon}"></i>
//             ${SPENDING_CATEGORIES[categoryKey].name}
//         </div>
//         <div class="item-grid">
//             ${getSelectedItems(categoryKey)
//                 .map(item => createItemRow(item, categoryKey, prefix).outerHTML)
//                 .join('')}
//         </div>
//     `;
//     parentElement.appendChild(section);
// }

function getSelectedItems(category) {
    const selections = getStoredSelections();
    const selectedItems = selections[category] || [];
    
    // Shuffle the selected items and pick the first two
    const shuffled = selectedItems.sort(() => Math.random() - 0.5);
    return shuffled.slice(0, 2).map(itemName => {
        return SPENDING_CATEGORIES[category].items.find(item => item.name === itemName);
    }).filter(item => item);
}



function populateCategorySection(parentElement, categoryKey, prefix = '') {
    const section = document.createElement('div');
    section.className = 'category-section';
    section.innerHTML = `
        <div class="category-title">
            <i class="${SPENDING_CATEGORIES[categoryKey].icon}"></i>
            ${SPENDING_CATEGORIES[categoryKey].name}
        </div>
        <div class="item-grid">
            ${getSelectedItems(categoryKey)
                .map(item => createItemRow(item, categoryKey, prefix).outerHTML)
                .join('')}
        </div>
    `;
    parentElement.appendChild(section);
}




// Get all the stage dots
const dots = document.querySelectorAll('.stage-dot');

// Update each dot's state
dots.forEach(dot => {
    const stageName = dot.dataset.stage; // Access the data-stage value
    if (stageName === currentStage) {
        dot.classList.add('active');
    }
});




function getTotalAmount(stageName) {
    const stage = STAGES[stageName];
    if (!stage) return 0;

    let total = stage.base_salary || 0;
    if (stage.additional_payment) total += stage.additional_payment;

    if (stageData[stageName]?.shockAmount) {
        total -= stageData[stageName].shockAmount;
    }

    return total;
}




// function updateAmount() {
//     const stage = STAGES[currentStage];
//     if (!stage) return;

//     const inputs = document.querySelectorAll('input[type="number"]');
//     let spent = 0;
//     inputs.forEach(input => {
//         spent += parseInt(input.value) || 0;
//     });

//     const totalAmount = getTotalAmount(currentStage);
//     const remaining = totalAmount - spent;

//     // Update the displayed amounts
//     document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
//     document.getElementById('spent-amount').textContent = `${spent.toLocaleString()} NGN`;
//     document.getElementById('remaining-amount').textContent = `${remaining.toLocaleString()} NGN`;

//     // Update progress bar
//     const progressPercentage = (spent / totalAmount) * 100;
//     document.getElementById('progress').style.width = `${Math.min(progressPercentage, 100)}%`;

//     // Add error highlighting if overspending occurs
//     const remainingElement = document.getElementById('remaining-amount');
//     remainingElement.style.color = remaining < 0 ? 'red' : '';
// }



function updateAmount() {
    const stage = STAGES[currentStage];
    if (!stage) return;

    const inputs = document.querySelectorAll('input[type="number"]');
    let spent = 0;

    inputs.forEach(input => {
        spent += parseInt(input.value) || 0;
    });

    // Adjust total based on shock amount
    const totalAmount = getTotalAmount(currentStage);
    const remaining = totalAmount - spent;

    // Update displayed amounts
    document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
    document.getElementById('spent-amount').textContent = `${spent.toLocaleString()} NGN`;
    document.getElementById('remaining-amount').textContent = `${remaining.toLocaleString()} NGN`;

    // Update progress bar
    const progressPercentage = (spent / totalAmount) * 100;
    document.getElementById('progress').style.width = `${Math.min(progressPercentage, 100)}%`;

    // Update colors based on remaining amount
    const remainingElement = document.getElementById('remaining-amount');
    if (remaining < 0) {
        remainingElement.style.color = 'red'; // Overspending
    } else if (remaining > 0) {
        remainingElement.style.color = 'blue'; // Under-allocated
    } else {
        remainingElement.style.color = ''; // Fully allocated
    }
}





function updateStageIndicators() {
    const stageSequence = Object.keys(STAGES); // Dynamically get all stage keys
    document.querySelectorAll('.stage-dot').forEach((dot, index) => {
        const stageName = stageSequence[index];
        dot.dataset.stage = stageName;
        dot.classList.toggle('active', stageName === currentStage);
        dot.classList.toggle(
            'completed',
            stageSequence.indexOf(stageName) < stageSequence.indexOf(currentStage)
        );
    });
}





// Modified updateSplitAmount to handle shock amounts
function updateSplitAmount() {
    let salaryValid = true;
    let bonusValid = true;
    
    const stage = STAGES[currentStage];
    const isConditionA = currentStage === 'condition_a';
    
    // Set correct amounts based on stage
    const salaryTarget = isConditionA ? 6000 : 10000;
    const bonusTarget = isConditionA ? 4000 : 5000;
    
    // Get stored shock amount if any
    const currentStageData = stageData[currentStage] || {};
    const shockReduction = currentStageData.shockAmount || 0;
    const shockPerSection = shockReduction / 2;
    
    ['salary', 'bonus'].forEach(section => {
        const inputs = document.querySelectorAll(`input[name^="${section}_"]`);
        let spent = 0;
        inputs.forEach(input => {
            spent += parseInt(input.value) || 0;
        });
        
        const target = section === 'salary' ? salaryTarget : bonusTarget;
        const adjustedTarget = target - shockPerSection;
        
        // Update displays with shock-adjusted amounts
        const remaining = adjustedTarget - spent;
        document.getElementById(`${section}-spent`).textContent = `${spent.toLocaleString()} NGN`;
        document.getElementById(`${section}-remaining`).textContent = `${remaining.toLocaleString()} NGN`;
        document.getElementById(`${section}-progress`).style.width = `${(spent / target) * 100}%`;
        
        // Validate based on condition and shock adjustment
        if (isConditionA) {
            if (spent !== adjustedTarget) {
                inputs.forEach(input => input.classList.add('error'));
                document.getElementById(`${section}-remaining`).style.color = 'red';
                if (section === 'salary') salaryValid = false;
                else bonusValid = false;
            } else {
                inputs.forEach(input => input.classList.remove('error'));
                document.getElementById(`${section}-remaining`).style.color = '';
            }
        } else {
            if (spent > adjustedTarget) {
                inputs.forEach(input => input.classList.add('error'));
                document.getElementById(`${section}-remaining`).style.color = 'red';
                if (section === 'salary') salaryValid = false;
                else bonusValid = false;
            } else {
                inputs.forEach(input => input.classList.remove('error'));
                document.getElementById(`${section}-remaining`).style.color = '';
            }
        }
    });
    
    document.getElementById('submit-button').disabled = !(salaryValid && bonusValid);
}



// Modified updateRegularAmount function to handle condition_b1 consistently with condition_b
function updateRegularAmount() {
    const inputs = document.querySelectorAll('input[type="number"]');
    let spent = 0;
    let isValid = true;
    
    // Get current stage data and shock information
    const currentStageData = stageData[currentStage] || {};
    const shockReduction = currentStageData.shockAmount || 0;
    
    // Calculate total amount available based on stage
    let maxAmount;
    if (currentStage === 'condition_b1') {
        maxAmount = 10000 - shockReduction;  // Now matches condition_b's base salary logic
    } else {
        maxAmount = totalAmount;
    }
    
    // Calculate spent amount
    inputs.forEach(input => {
        const value = parseInt(input.value) || 0;
        spent += value;
        
        // Add validation
        if (spent > maxAmount) {
            input.classList.add('error');
            isValid = false;
        } else {
            input.classList.remove('error');
        }
    });

    

    

// Remove redundant event listener that had incorrect bonus amount
// Correctly setup the submit button listener
// function onSubmitButtonClick(e) {
//     e.preventDefault();

//     if (validateAllocations()) {
//         const speedBonus = calculateSpeedBonus(timeRemaining);
//         totalEarnings += speedBonus;

//         if (speedBonus > 0) {
//             alert(`Speed bonus achieved! +â‚¦${speedBonus.toLocaleString()}`);
//         }

//         const stageEarnings = calculateStageEarnings(currentStage);
//         totalEarnings += stageEarnings;

//         document.getElementById('totalEarnings').textContent = 
//             `â‚¦${totalEarnings.toLocaleString()}`;
        
//         clearInterval(timerInterval);
//         resetShockEvent();
//         document.getElementById('shockEvent').style.display = 'flex';
//     }
// }

// // Attach the corrected listener
// document.getElementById('submit-button').removeEventListener('click', onSubmitButtonClick);
// document.getElementById('submit-button').addEventListener('click', onSubmitButtonClick);





    
    // Update display colors based on validation
    const remainingElement = document.getElementById('remaining-amount');
    remainingElement.style.color = isValid ? '' : 'red';
    remainingElement.textContent = `${(totalAmount - spent).toLocaleString()} NGN`;
    
    // Update other displays
    document.getElementById('spent-amount').textContent = `${spent.toLocaleString()} NGN`;
    
    const percentage = (spent / totalAmount) * 100;
    document.getElementById('progress').style.width = `${Math.min(percentage, 100)}%`;
}



// Modified setupSplitView function to handle both split view stages correctly
function setupSplitView() {
    const stage = STAGES[currentStage];
    const salarySection = document.getElementById('salary-allocations');
    const bonusSection = document.getElementById('bonus-allocations');
    
    // Clear existing content
    salarySection.innerHTML = '';
    bonusSection.innerHTML = '';
    
    // Set correct amounts in headers based on stage
    const salaryHeader = document.querySelector('.split-section:first-child .split-header');
    const bonusHeader = document.querySelector('.split-section:last-child .split-header');
    
    if (currentStage === 'condition_a') {
        salaryHeader.textContent = 'Regular Salary (6,000 NGN)';
        bonusHeader.textContent = 'Additional Payment (4,000 NGN)';
    } else if (currentStage === 'condition_b') {
        salaryHeader.textContent = 'Regular Salary (10,000 NGN)';
        bonusHeader.textContent = 'Meal Bonus (5,000 NGN)';
    }
    
    // Create and populate category sections
    Object.keys(SPENDING_CATEGORIES).forEach(categoryKey => {
        populateCategorySection(salarySection, categoryKey, 'salary_');
        populateCategorySection(bonusSection, categoryKey, 'bonus_');
    });
    
    // Initialize displays
    updateSplitAmount();
}



function updateTotalAmount(change) {
    totalAmount += change;
    document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
    document.getElementById('remaining-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
    document.getElementById('totalEarnings').textContent = `â‚¦${totalEarnings.toLocaleString()}`;
}



// // Modified updateInterface function to properly reset condition_b1
// function updateInterface() {

//     // Reset shock UI at the start of a new stage
//     resetShockEvent();

//     const stage = STAGES[currentStage];
//     document.getElementById('scenario-title').textContent = stage.title;
//     document.getElementById('scenario-description').innerHTML = stage.description;

//     startTimer();

//     // Clear any existing stage data when entering a new stage
//     if (!stageData[currentStage]) {
//         stageData[currentStage] = {
//             shockApplied: false,
//             shockAmount: 0
//         };
//     }

//     // Reset total amount at the start of each stage
//     if (currentStage === 'condition_b1') {
//         // Always start condition_b1 with 10,000 NGN
//         totalAmount = 10000;
//         // Only apply shock if it happened in THIS stage
//         if (stageData[currentStage].shockApplied) {
//             totalAmount -= stageData[currentStage].shockAmount;
//         }
//     } else {
//         totalAmount = stage.base_salary + (stage.additional_payment || 0);
//         if (stageData[currentStage].shockApplied) {
//             totalAmount -= stageData[currentStage].shockAmount;
//         }
//     }

//     // Handle view type
//     if (['condition_a1', 'condition_b1'].includes(currentStage)) {
//         document.getElementById('split-view').style.display = 'grid';
//         document.getElementById('regular-view').style.display = 'none';
//         setupSplitView();
//     } else {
//         document.getElementById('split-view').style.display = 'none';
//         document.getElementById('regular-view').style.display = 'block';
        
//         // Update displays with correct initial amount
//         document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
//         document.getElementById('remaining-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
//         document.getElementById('spent-amount').textContent = '0 NGN';
//         document.getElementById('progress').style.width = '0%';
        
//         // Clear and repopulate spending categories
//         Object.keys(SPENDING_CATEGORIES).forEach(categoryKey => {
//             const gridElement = document.getElementById(`${categoryKey}-grid`);
//             gridElement.innerHTML = '';
//             getRandomItems(categoryKey, 2).forEach(item => {
//                 gridElement.appendChild(createItemRow(item, categoryKey));
//             });
//         });
//     }

//     // Reset all input values
//     document.querySelectorAll('input[type="number"]').forEach(input => {
//         input.value = '';
//     });

//     // Update validation states
//     if (['condition_a1', 'condition_b1'].includes(currentStage)) {
//         updateSplitAmount();
//     } else {
//         updateRegularAmount();
//     }

//     // Reset earnings display at game start
//     if (currentStage === 'baseline') {
//         totalEarnings = 0;
//         document.getElementById('totalEarnings').textContent = 'â‚¦0';
//     }

//     updateStageIndicators();
// }



function updateInterface() {
    resetShockEvent();

    const stage = STAGES[currentStage];
    const isDescriptionPage = stage.isDescriptionPage || false;

    // Update basic UI elements
    document.getElementById('scenario-title').textContent = stage.title;
    document.getElementById('scenario-description').innerHTML = typeof stage.description === 'function' 
        ? stage.description() 
        : stage.description;

    const allocationForm = document.getElementById('allocation-form');
    const progressContainer = document.querySelector('.progress-container');
    const scenarioElement = document.getElementById('scenario');
    const controlsSection = document.querySelector('.controls-section');

    if (!stageData[currentStage]) {
        stageData[currentStage] = { shockApplied: false, shockAmount: 0 };
    }

    // Calculate the total amount including shocks
    totalAmount = stage.base_salary + (stage.additional_payment || 0);
    if (stageData[currentStage].shockApplied) {
        totalAmount -= stageData[currentStage].shockAmount;
    }

    // Initialize UI for budget and inputs
    if (!isDescriptionPage) {
        allocationForm.style.display = 'block';
        progressContainer.style.visibility = 'visible';
        scenarioElement.style.margin = 'initial';

        document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
        document.getElementById('remaining-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
        document.getElementById('spent-amount').textContent = '0 NGN';
        document.getElementById('progress').style.width = '0%';

        controlsSection.innerHTML = `
            <button id="submit-button" onclick="handleSubmit()">Submit Choices</button>
        `;
    } else {
        allocationForm.style.display = 'none';
        progressContainer.style.visibility = 'hidden';
        scenarioElement.style.margin = '2em auto';

        controlsSection.innerHTML = `
            <button id="next-button" onclick="proceedToNextStage()">Next</button>
        `;
    }

    // Clear inputs and repopulate categories
    document.querySelectorAll('input[type="number"]').forEach(input => input.value = '');
    if (['condition_a1', 'condition_b1'].includes(currentStage)) {
        setupSplitView();
        updateSplitAmount();
    } else {
        updateBudgetDisplay();
        updateRegularAmount();
    }

    if (currentStage === 'baseline') {
        totalEarnings = 0;
        document.getElementById('totalEarnings').textContent = 'â‚¦0';
    }

    updateStageIndicators();
}




















function addCelebratoryEffects() {
    const scenario = document.getElementById('scenario');

    if (!document.querySelector('.celebration')) {
        scenario.innerHTML += `
            <div class="celebration">
                <div class="balloons">
                    <div style="left: 20%; background-color: #ff9999;"></div>
                    <div style="left: 50%; background-color: #99ccff;"></div>
                    <div style="left: 80%; background-color: #ffcc99;"></div>
                </div>
                <div class="sparks"></div>
            </div>
        `;
    }

    scenario.classList.add('animate-celebration');
}



// Helper function to remove celebratory effects
function removeCelebratoryEffects() {
    const celebration = document.querySelector('.celebration');
    if (celebration) celebration.remove();
    document.getElementById('scenario').classList.remove('animate-celebration');
}

// Helper function to update the budget display dynamically
function updateBudgetDisplay() {
    document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
    document.getElementById('remaining-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
    document.getElementById('spent-amount').textContent = '0 NGN';
    document.getElementById('progress').style.width = '0%';

    // Clear and repopulate spending categories
    Object.keys(SPENDING_CATEGORIES).forEach(categoryKey => {
        const gridElement = document.getElementById(`${categoryKey}-grid`);
        gridElement.innerHTML = '';
        getRandomItems(categoryKey, 2).forEach(item => {
            gridElement.appendChild(createItemRow(item, categoryKey));
        });
    });
}




let preShockCategorySum = 0; // Variable to track the initial category sum before shock






// function proceedToNextStage() {
//     const categorySum = calculateCategoryEarnings(); // Calculate category earnings
//     const speedBonus = timeRemaining > 0 ? 0 : 0; // Apply speed bonus if applicable

//     // Display earnings breakdown
//     showEarningsBreakdown(categorySum, speedBonus);

//     // Transition to the next stage
//     const stageSequence = Object.keys(STAGES);
//     const currentIndex = stageSequence.indexOf(currentStage);

//     if (currentIndex < stageSequence.length - 1) {
//         currentStage = stageSequence[currentIndex + 1];
//         showStageData(currentStage);
//         updateInterface();
//     } else {
//         // End of game logic
//         document.getElementById('game-complete').style.display = 'block';
//         alert(`ðŸŽ‰ Game Over! Your total earnings are â‚¦${totalEarnings.toLocaleString()}!`);
//     }
// }


function proceedToNextStage() {
    // Stop the current timer
    clearInterval(timerInterval);

    const categorySum = calculateCategoryEarnings(); // Calculate category earnings
    const speedBonus = timeRemaining > 0 ? 500 : 0; // Apply speed bonus if applicable

    // Display earnings breakdown
    showEarningsBreakdown(categorySum, speedBonus);

    // Transition to the next stage
    const stageSequence = Object.keys(STAGES);
    const currentIndex = stageSequence.indexOf(currentStage);

    if (currentIndex < stageSequence.length - 1) {
        currentStage = stageSequence[currentIndex + 1];
       
        updateInterface();

        // Restart the timer for the new stage
        startTimer();
    } else {
        // End of game logic
        document.getElementById('game-complete').style.display = 'block';
        alert(`ðŸŽ‰ Game Over! Your total earnings are â‚¦${totalEarnings.toLocaleString()}!`);
    }
}









function showShockEvent() {
    const category = stageCategory || selectRandomCategory();
    console.log('Current category:', category);

    const preShockCategorySum = calculateSelectedCategoryEarnings(category);

    totalEarnings += preShockCategorySum;

    // Save to the specific stage table
    insertStageData(currentStage, {
        date: new Date().toLocaleDateString(),
        time: new Date().toLocaleTimeString(),
        user_id: 'user123', // Replace with dynamic user ID if available
        total_amount: totalEarnings,
        shock_amount: preShockCategorySum,
        specific_option: category,
        total_earning: totalEarnings,
    });

    document.getElementById('totalEarnings').textContent = `â‚¦${totalEarnings.toLocaleString()}`;
    document.getElementById('shockEvent').style.display = 'flex';
}






// Function to select a random category
function selectRandomCategory() {
    const categories = Object.keys(SPENDING_CATEGORIES);
    return categories[Math.floor(Math.random() * categories.length)];
}



// function calculateSelectedCategoryEarnings(category) {
//     // Select all inputs for the given category
//     const inputs = document.querySelectorAll(`input[name*="${category}"]`);

//     // Log inputs for debugging
//     if (inputs.length === 0) {
//         console.error(`No inputs found for category: ${category}`);
//         return 0;
//     }

//     let total = 0;

//     inputs.forEach(input => {
//         const value = parseInt(input.value) || 0; // Ensure value is a valid integer
//         if (isNaN(value)) {
//             console.warn(`Invalid input value for category: ${category}, input: ${input.name}`);
//         }
//         total += value;
//     });

//     // Log total for debugging
//     console.log(`Calculated earnings for category ${category}: â‚¦${total}`);
//     return total;
// }


function calculateSelectedCategoryEarnings(category) {
    console.log('Category passed to the function:', category); // Debug the passed category value

    // Select all inputs for the given category
    const inputs = document.querySelectorAll(`input[name*="${category}"]`);

    // Log inputs for debugging
    if (inputs.length === 0) {
        console.error(`No inputs found for category: ${category}`);
        return 0;
    }

    let total = 0;

    inputs.forEach(input => {
        const value = parseInt(input.value) || 0; // Ensure value is a valid integer
        if (isNaN(value)) {
            console.warn(`Invalid input value for category: ${category}, input: ${input.name}`);
        }
        total += value;
    });

    // Log total for debugging
    console.log(`Calculated earnings for category ${category}: â‚¦${total}`);
    return total;
}





function showShockEvent() {
    let speedBonus = 0;

    // Apply speed bonus if applicable
    if (timeRemaining > 0) {
        speedBonus = 0;
    }

    // Adjust total earnings for the shock
    const preShockCategorySum = calculateSelectedCategoryEarnings(stageCategory || selectRandomCategory());
 
    const totalEarningsWithShock = preShockCategorySum  + speedBonus;

    totalEarnings += totalEarningsWithShock;
    document.getElementById('totalEarnings').textContent = `â‚¦${totalEarnings.toLocaleString()}`;

    // Display the shock event modal
    document.getElementById('shockEvent').style.display = 'flex';
}






function updateTotalEarningsDisplay() {
    if (!isNaN(totalEarnings) && totalEarnings >= 0) {
        document.getElementById('totalEarnings').textContent = `â‚¦${totalEarnings.toLocaleString()}`;
    } else {
        console.error("Total Earnings is invalid (NaN or negative)");
        document.getElementById('totalEarnings').textContent = `â‚¦0`;
        totalEarnings = 0; // Reset to a safe value
    }
}





let stageCategory; // Store the randomly selected category for the current stage

function selectRandomCategory() {
    const categories = Object.keys(SPENDING_CATEGORIES);
    stageCategory = categories[Math.floor(Math.random() * categories.length)];
    console.log(`Randomly selected category: ${stageCategory}`);
}




function calculateCategoryEarnings() {
  const categories = Object.keys(SPENDING_CATEGORIES);
  console.log('Extracted categories:', categories);

  if (categories.length === 0) {
    console.error('SPENDING_CATEGORIES has no categories.');
    return 0;
  }

  // Select a random category
  const randomCategory = categories[Math.floor(Math.random() * categories.length)];
  if (!randomCategory) {
    console.error('Failed to select a random category.');
    return 0;
  }

  console.log('Selected random category:', randomCategory);

  // Get all inputs matching the selected category
  const categoryInputs = document.querySelectorAll(`input[name^="${randomCategory}_"]`);
  console.log(`Inputs for category "${randomCategory}":`, categoryInputs);

  if (!categoryInputs.length) {
    console.warn(`No inputs found for category: ${randomCategory}`);
    return 0;
  }

  // Sum the inputs
  const sum = Array.from(categoryInputs).reduce((total, input) => {
    const value = parseInt(input.value) || 0;
    return total + value;
  }, 0);

  console.log(`Category: ${randomCategory}, Sum: â‚¦${sum}`);
  return sum;
}




// function proceedToNextStage() {
//     const categorySum = calculateCategoryEarnings();
//     const speedBonus = timeRemaining > 0 ? 500 : 0;

//     // Exclude shock amount in earnings breakdown
//     showEarningsBreakdown(categorySum, speedBonus);

//     const stageSequence = Object.keys(STAGES);
//     const currentIndex = stageSequence.indexOf(currentStage);

//     if (currentIndex < stageSequence.length - 1) {
//         currentStage = stageSequence[currentIndex + 1];
//         updateInterface();
//     } else {
//         alert(`ðŸŽ‰ Game Over! Your total earnings are â‚¦${totalEarnings.toLocaleString()}!`);
//     }
// }





function continueGame() {
    if (shockAmount > 0) {
        const stage = STAGES[currentStage];
        const totalBaseAmount = (stage.base_salary || 0) + (stage.additional_payment || 0);

        // Adjust the working budget for the shock
        totalAmount = totalBaseAmount - shockAmount;

        // Notify the user about the new budget
        alert(`An unexpected expense of â‚¦${shockAmount.toLocaleString()} has occurred!
Your updated budget is now â‚¦${totalAmount.toLocaleString()}.`);

        // Update the UI to reflect the new budget
        document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
        document.getElementById('remaining-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
        document.getElementById('spent-amount').textContent = '0 NGN';
        document.getElementById('progress').style.width = '0%';

        // Store the shock data
        stageData[currentStage] = {
            ...stageData[currentStage],
            shockAmount: shockAmount,
            shockApplied: true,
        };

        // Restart the timer
        clearInterval(timerInterval); // Stop any existing timer
        startTimer(); // Restart the timer

        // Reload UI and proceed with adjustments
        updateScenarioAfterShock();
        updateRegularAmount();
        document.getElementById('shockEvent').style.display = 'none';
    }
}



function continueGame() {
    if (shockAmount > 0) {
        const stage = STAGES[currentStage];
        const totalBaseAmount = (stage.base_salary || 0) + (stage.additional_payment || 0);

        // Calculate the new budget after applying the shock
        totalAmount = totalBaseAmount - shockAmount;

        // Notify the user about the budget adjustment
        alert(`An unexpected expense of â‚¦${shockAmount.toLocaleString()} has occurred!
Your updated budget is now â‚¦${totalAmount.toLocaleString()}.`);

        // Update the UI to reflect the new budget
        document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
        document.getElementById('remaining-amount').textContent = `${totalAmount.toLocaleString()} NGN`;
        document.getElementById('spent-amount').textContent = '0 NGN';
        document.getElementById('progress').style.width = '0%';

        // Save the shock data to the stageData object
        stageData[currentStage] = {
            ...stageData[currentStage],
            shockAmount: shockAmount,
            shockApplied: true,
            adjustmentSubmitted: false, // Reset adjustment flag if needed
        };

        // Save updated stage data to localStorage (or API if applicable)
        try {
            localStorage.setItem('stageData', JSON.stringify(stageData));
        } catch (error) {
            console.error("Failed to save stage data:", error);
        }

        // Reset the shock amount to prevent duplicate adjustments
        shockAmount = 0;

        // Restart the timer for the stage
        clearInterval(timerInterval); // Stop the existing timer
        startTimer(); // Restart the timer

        // Refresh the UI and game state
        updateScenarioAfterShock();
        updateRegularAmount();

        // Hide the shock event modal
        document.getElementById('shockEvent').style.display = 'none';

        // Provide user feedback on readiness
        console.log("Shock adjustments applied successfully. Ready to continue.");
    } else {
        // Log a warning if no shock amount is detected
        alert("No shock adjustment needed. Please proceed.");
        console.warn("continueGame called with shockAmount <= 0.");
    }
}




function showEarningsBreakdown(preShockCategorySum, speedBonus) {
    preShockCategorySum = Number(preShockCategorySum) || 0;
    speedBonus = Number(speedBonus) || 0;

    // Display earnings breakdown without updating totalEarnings again
    alert(`
    Earnings Breakdown:
    - Current Earnings (from Sum of a Random Category): â‚¦${preShockCategorySum.toLocaleString()}
    - Speed Bonus: â‚¦${speedBonus.toLocaleString()}
    Total Earnings So Far: â‚¦${totalEarnings.toLocaleString()}
    Keep pushing forward! You're doing great. ðŸ’°
    `);
}







// function handleSubmit() {
//     const categorySum = calculateCategoryEarnings(); // Calculate earnings for the category
//     const speedBonus = 0// Add speed bonus if applicable

//     if (!isNaN(categorySum) && categorySum >= 0) {
//         totalEarnings += categorySum + speedBonus; // Exclude shockAmount
//         console.log(`Category Earnings: â‚¦${categorySum}, Speed Bonus: â‚¦${speedBonus}`);
//     } else {
//         console.error("Invalid earnings calculation. Skipping update.");
//     }

//     // Update display and proceed
//     updateTotalEarningsDisplay();
//     proceedToNextStage();
// }





// function handleSubmit() {
//     if (validateAllocations()) {
//         const stage = STAGES[currentStage];
//         const categorySum = calculateCategoryEarnings();
//         const preShockBonus = stage.additional_payment || 0;
//         let speedBonus = 0;

//         // Calculate speed bonus once
//         if (timeRemaining > 0) {
//             speedBonus = 500;
//         }

//         // Add earnings to total without duplication
//         const preShockEarnings = categorySum + preShockBonus + speedBonus;
//         totalEarnings += preShockEarnings; 

//         // Store the pre-shock category sum for later reference
//         preShockCategorySum = categorySum;

//         // Display speed bonus only once
//         if (speedBonus > 0) {
//             alert(`Speed bonus achieved! +â‚¦${speedBonus.toLocaleString()}`);
//         }

//         // Clear timer and proceed to the shock event
//         clearInterval(timerInterval);
//         showShockEvent();
//     }
// }



// function handleSubmit() {
//    if (validateAllocations()) {
//        const stage = STAGES[currentStage];
//        const categorySum = calculateCategoryEarnings();
//        const preShockBonus = stage.additional_payment || 0;
//        let speedBonus = 0;


//        // Calculate speed bonus once
//        if (timeRemaining > 0) {
//            speedBonus = 500; // Example bonus value; adjust as needed
//        }


//        // Add earnings to total without duplication
//        const preShockEarnings = categorySum + preShockBonus + speedBonus;
//        totalEarnings += preShockEarnings;


//        // Store the pre-shock category sum for later reference
//        preShockCategorySum = categorySum;


//        // Display speed bonus message only once
//        if (speedBonus > 0) {
//            alert(`Speed bonus achieved! +â‚¦${speedBonus.toLocaleString()}`);
//        }





//        // Clear timer and determine next steps
//        clearInterval(timerInterval);


//        if (!stageData[currentStage]?.shockApplied) {
//            // Show shock event only if it has not occurred in this stage
//            showShockEvent();
//            stageData[currentStage] = {
//                ...stageData[currentStage],
//                shockApplied: true,
//            };
//        } else {
//            // If shock event already occurred, proceed to the next stage
//            proceedToNextStage();
//        }
//    }
// }







// function handleSubmit() {
//     if (validateAllocations()) {
//         const stage = STAGES[currentStage];
//         const categorySum = calculateCategoryEarnings();
//         const preShockBonus = stage.additional_payment || 0;
//         const speedBonus = timeRemaining > 0 ? 500 : 0;

//         const preShockEarnings = categorySum + preShockBonus + speedBonus;
//         totalEarnings += preShockEarnings;
//         preShockCategorySum = categorySum;

//         if (speedBonus > 0) {
//             alert(`Speed bonus achieved! +â‚¦${speedBonus.toLocaleString()}`);
//         }

//         // Enhanced allocations structure
//         const allocations = {};

//         document.querySelectorAll('input[type="number"]').forEach(input => {
//             const [categoryName, optionName] = input.name.split('_'); // Split into category and option
//             if (!allocations[categoryName]) {
//                 allocations[categoryName] = { total: 0, options: {} };
//             }

//             const value = parseInt(input.value) || 0;
//             allocations[categoryName].total += value; // Add to category total
//             allocations[categoryName].options[optionName] = value; // Store specific option value
//         });

//         const stageDataToSave = {
//             date: new Date().toLocaleDateString(),
//             time: new Date().toLocaleTimeString(),
//             user_id: "player1",
//             total_amount: totalAmount,
//             shock_amount: shockAmount,
//             total_earning: totalEarnings,
//             specific_option: "exampleOption", // Replace with the actual selected option
//             speed_bonus: speedBonus,
//             pre_shock_earnings: preShockEarnings,
//             amount_allocated_options: allocations // Enhanced data structure
//         };

//         insertStageData(currentStage, stageDataToSave);
//         clearInterval(timerInterval);

//         if (!stageData[currentStage]?.shockApplied) {
//             showShockEvent();
//             stageData[currentStage] = { ...stageData[currentStage], shockApplied: true };
//         } else {
//             saveGameData(); // Call the API to save the current game state
//             proceedToNextStage();
//         }
//     }
// }



// const isProd = window.location.hostname !== 'localhost';
// const API_BASE_URL = isProd ? '' : 'http://localhost:3080';


function getApiBaseUrl() {
    const isLocalhost = window.location.hostname === 'localhost';
    return isLocalhost ? 'http://localhost:3000' : window.location.origin;
}


function handleSubmit() {
    if (!validateAllocations()) {
        return;
    }

    const stage = STAGES[currentStage];
    const categorySum = calculateCategoryEarnings();
    const preShockBonus = stage.additional_payment || 0;
    const speedBonus = timeRemaining > 0 ? 500 : 0;

    const preShockEarnings = categorySum + preShockBonus + speedBonus;
    totalEarnings += preShockEarnings;
    preShockCategorySum = categorySum;

    if (speedBonus > 0) {
        alert(`Speed bonus achieved! +â‚¦${speedBonus.toLocaleString()}`);
    }

    // Build allocation structure
    const allocations = {};
    document.querySelectorAll('input[type="number"]').forEach(input => {
        const [categoryName, optionName] = input.name.split('_');
        if (!allocations[categoryName]) {
            allocations[categoryName] = { total: 0, options: {} };
        }
        const value = parseInt(input.value) || 0;
        allocations[categoryName].total += value;
        allocations[categoryName].options[optionName] = value;
    });

    const stageDataToSave = {
        stageName: stage.name || currentStage,
        date: new Date().toLocaleDateString(),
        time: new Date().toLocaleTimeString(),
        user_id: "player1",
        total_amount: totalAmount,
        shock_amount: shockAmount,
        total_earning: totalEarnings,
        specific_option: "exampleOption",
        speed_bonus: speedBonus,
        pre_shock_earnings: preShockEarnings,
        amount_allocated_options: allocations,
        is_post_shock: stageData[currentStage]?.shockApplied || false // Track shock state
    };

    insertStageData(currentStage, stageDataToSave);
    clearInterval(timerInterval);

    if (!stageData[currentStage]?.shockApplied) {
        // Pre-shock submission
        saveGameData({ ...stageDataToSave, is_post_shock: false })
            .then(() => {
                console.log('Pre-shock data saved successfully');
                showShockEvent();
                stageData[currentStage] = { 
                    ...stageData[currentStage], 
                    shockApplied: true 
                };
            })
            .catch(error => {
                console.error('Failed to save pre-shock data:', error);
                alert('Error saving pre-shock data. Please try again.');
            });
    } else if (!stageData[currentStage]?.adjustmentSubmitted) {
        // Post-shock submission
        stageData[currentStage] = {
            ...stageData[currentStage],
            adjustmentSubmitted: true
        };
        saveGameData({ ...stageDataToSave, is_post_shock: true })
            .then(() => {
                console.log('Post-shock data saved successfully');
                proceedToNextStage();
            })
            .catch(error => {
                console.error('Failed to save post-shock data:', error);
                alert('Error saving post-shock data. Please try again.');
            });
    }
}


// New function to calculate earnings from a random category
function calculateRandomCategoryEarnings() {
    const categories = Object.keys(SPENDING_CATEGORIES);
    const randomCategory = categories[Math.floor(Math.random() * categories.length)];
    
    // Get all inputs from the selected category
    const categoryInputs = document.querySelectorAll(
        `input[name*="${randomCategory}"]`
    );
    
    // Sum the inputs with a random factor
    return Array.from(categoryInputs).reduce((sum, input) => {
        const value = parseInt(input.value) || 0;
        const randomFactor = Math.random() * 0.2 + 0.9; // Random factor between 0.9 and 1.1
        return sum + (value * randomFactor);
    }, 0);
}






// Helper function to calculate section total with random selection
function calculateSectionTotal(section) {
    return Array.from(document.querySelectorAll(`input[name^="${section}_"]`))
        .reduce((sum, input) => {
            const value = parseInt(input.value) || 0;
            // Add some randomization to the earnings calculation
            const randomFactor = Math.random() * 0.2 + 0.9; // Random factor between 0.9 and 1.1
            return sum + (value * randomFactor);
        }, 0);
}

// Helper function to calculate total spent with random selection
function calculateTotalSpent() {
    return Array.from(document.querySelectorAll('input[type="number"]'))
        .reduce((sum, input) => {
            const value = parseInt(input.value) || 0;
            // Add some randomization to the earnings calculation
            const randomFactor = Math.random() * 0.2 + 0.9; // Random factor between 0.9 and 1.1
            return sum + (value * randomFactor);
        }, 0);
}






const submitButton = document.getElementById('submit-button');
const newSubmitButton = submitButton.cloneNode(true);
submitButton.parentNode.replaceChild(newSubmitButton, submitButton);

newSubmitButton.removeEventListener('click', handleSubmit); // Ensure no old listeners
newSubmitButton.addEventListener('click', handleSubmit);


// function validateAllocations() {
//     const totalAmount = getTotalAmount(currentStage);
//     const inputs = document.querySelectorAll('input[type="number"]');
//     let totalSpent = 0;

//     inputs.forEach(input => {
//         totalSpent += parseInt(input.value) || 0;
//     });

//     if (inputs.length === 0) {
//         console.warn("No allocations available for validation.");
//         return true; // Skip validation for stages without inputs
//     }

//     if (totalSpent !== totalAmount) {
//         alert(`Please ensure your allocations match the total amount of ${totalAmount.toLocaleString()} NGN. You have allocated ${totalSpent.toLocaleString()} NGN.`);
//         return false;
//     }

//     return true;
// }



function validateAllocations() {
    const totalAmount = getTotalAmount(currentStage);
    const inputs = document.querySelectorAll('input[type="number"]');
    let totalSpent = 0;

    inputs.forEach(input => {
        totalSpent += parseInt(input.value) || 0;
    });

    // Check for edge cases
    if (inputs.length === 0) {
        console.warn("No allocation inputs found for validation.");
        return true; // Allow stages without inputs to pass validation
    }

    // Validate allocation amounts
    if (totalSpent > totalAmount) {
        alert(`You have overspent by â‚¦${(totalSpent - totalAmount).toLocaleString()}. Adjust your allocations.`);
        return false;
    } else if (totalSpent < totalAmount) {
        alert(`You need to allocate the remaining â‚¦${(totalAmount - totalSpent).toLocaleString()}.`);
        return false;
    }

    // Passed validation
    return true;
}







// Helper functions for calculations
function calculateSectionTotal(section) {
    return Array.from(document.querySelectorAll(`input[name^="${section}_"]`))
        .reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
}

function calculateTotalSpent() {
    return Array.from(document.querySelectorAll('input[type="number"]'))
        .reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
}


newSubmitButton.addEventListener('click', function (e) {
    e.preventDefault();

    // Validate allocations
    if (!validateAllocations()) {
        return; // Stop if validation fails
    }

    const currentStageData = stageData[currentStage];
    const isPostShockAdjustment =
        currentStageData && currentStageData.shockApplied && !currentStageData.adjustmentSubmitted;

    if (isPostShockAdjustment) {
        // Handle post-shock adjustments
        stageData[currentStage].adjustmentSubmitted = true;

        // Save updated data
        localStorage.setItem('stageData', JSON.stringify(stageData));

        // Proceed to the next stage
        proceedToNextStage();
    } else {
        // Handle initial stage submission
        const categoryEarnings = calculateCategoryEarnings();
        const speedBonus = timeRemaining > 0 ? 500 : 0; // Speed bonus if time remains
        totalEarnings += categoryEarnings + speedBonus;

        // Feedback for speed bonus
        if (speedBonus > 0) {
            alert(`Speed bonus achieved! +â‚¦${speedBonus.toLocaleString()}`);
        }

        // Update earnings display
        document.getElementById('totalEarnings').textContent = `â‚¦${totalEarnings.toLocaleString()}`;
        alert(`You earned â‚¦${categoryEarnings.toLocaleString()} this stage!`);

        // Determine next step
        if (stageData[currentStage]?.shockApplied) {
            showShockEvent(); // Show shock if not already handled
        } else {
            proceedToNextStage(); // Move to the next stage
        }
    }

    // Stop the timer after submission
    clearInterval(timerInterval);
});





// Remove the old event listener completely
// Do not add any other submit button event listeners



// Initialize the game
// window.onload = function() {
//     // Add game header with earnings and timer
//     const gameHeader = document.createElement('div');
//     gameHeader.className = 'game-header';
//     gameHeader.innerHTML = `
//         <div class="earnings-display">
//             Total Earnings: <span id="totalEarnings">â‚¦0</span>
//         </div>
//         <div class="timer">
//             Time Remaining: <span id="timer">3:00</span>
//         </div>
//     `;
//     document.querySelector('.game-container').insertBefore(
//         gameHeader,
//         document.querySelector('.stage-indicator')
//     );
    
//     updateInterface();
// };



// Declare stageSequence as a global variable
let stageSequence = [];

// Modified event listener to set global stageSequence
document.addEventListener('DOMContentLoaded', function() {
    try {
        const savedStageSequence = localStorage.getItem('stageSequence');
        if (!savedStageSequence) {
            alert('Required game data missing! Redirecting to the start page.');
            window.location.href = 'start.html';
            return;
        }
        
        // Parse and validate the stage sequence
        stageSequence = JSON.parse(savedStageSequence);
        if (!Array.isArray(stageSequence) || stageSequence.length === 0) {
            throw new Error('Invalid stage sequence format');
        }
        
        // Initialize the game if all required data is present
        initializeGame();
    } catch (error) {
        console.error('Error loading stage sequence:', error);
        alert('Error loading game data! Redirecting to start page.');
        window.location.href = 'start.html';
    }
});

function initializeGame(selections) {
    totalEarnings = 0;

    // Create game header
    const gameHeader = document.createElement('div');
    gameHeader.className = 'game-header';
    gameHeader.innerHTML = `
        <div class="earnings-display">
            Total Earnings: <span id="totalEarnings">â‚¦${totalEarnings}</span>
        </div>
        <div class="timer">
            Time Remaining: <span id="timer">3:00</span>
        </div>
    `;
    
    const gameContainer = document.querySelector('.game-container');
    if (!gameContainer) {
        console.error('Game container not found!');
        return;
    }
    
    gameContainer.insertBefore(
        gameHeader,
        document.querySelector('.stage-indicator')
    );

    try {
        // Use the global stageSequence
        if (!Array.isArray(stageSequence) || stageSequence.length === 0) {
            throw new Error('Invalid stage sequence');
        }

        // Log the stage sequence to verify its correctness
        console.log('Current stage sequence:', stageSequence);

        currentStage = stageSequence[0];
        stageData[currentStage] = { shockApplied: false, shockAmount: 0 };

        // Apply selections if provided
        if (selections) {
            applySelections(selections);
        }

        updateInterface();
        
        // Start the timer for the first stage
        startTimer();
    } catch (error) {
        console.error('Error initializing game:', error);
        alert('Error initializing game! Returning to start page.');
        window.location.href = 'start.html';
    }
}






// Add window.onload event listener at the end of game.html
window.addEventListener('load', function () {
    const selections = localStorage.getItem('categorySelections');

    if (!selections) {
        // Redirect if no selections found
        window.location.href = 'selection.html';
        return;
    }

    const parsedSelections = JSON.parse(selections);
    console.log("Loaded categorySelections:", parsedSelections);

    Object.entries(parsedSelections).forEach(([categoryKey, items]) => {
        if (SPENDING_CATEGORIES[categoryKey]) {
            SPENDING_CATEGORIES[categoryKey].items = items.map(name => {
                const predefinedItem = SPENDING_CATEGORIES[categoryKey].items.find(item => item.name === name);
                return predefinedItem || { name, icon: "âœ¨" }; // Use default icon only for custom items
            });
        } else {
            console.warn(`Category ${categoryKey} not found in SPENDING_CATEGORIES!`);
        }
    });

    console.log("Updated SPENDING_CATEGORIES:", SPENDING_CATEGORIES);

    // Initialize the game UI
    updateInterface();
});





const SHOCK_EVENTS = [
    { text: "Surprise! Your friend's birthday party is tomorrow. Time to buy a gift! ðŸŽ", amount: 15000 },
    { text: "PHCN has disconnected your electricity without notice. Emergency reconnection needed! âš¡", amount: 20000 },
    { text: "Your phone screen cracked. Quick repair needed for work! ðŸ“±", amount: 18000 },
    { text: "Unexpected transportation fare increase this week! ðŸšŒ", amount: 12000 },
    { text: "Emergency medical consultation needed! ðŸ¥", amount: 17000 },
    { text: "Great news! No unexpected expenses this month. You're all set! ðŸ˜Š", amount: 0 },
    { text: "Nothing unusual happened this month. Enjoy your smooth sailing! ðŸš€", amount: 0 },
    { text: "Great news! No unexpected expenses this month. You're all set! ðŸ˜Š", amount: 0 },
    { text: "Nothing unusual happened this month. Enjoy your smooth sailing! ðŸš€", amount: 0 },
    { text: "Great news! No unexpected expenses this month. You're all set! ðŸ˜Š", amount: 0 },
    { text: "Nothing unusual happened this month. Enjoy your smooth sailing! ðŸš€", amount: 0 },
    { text: "Great news! No unexpected expenses this month. You're all set! ðŸ˜Š", amount: 0 },
    { text: "Nothing unusual happened this month. Enjoy your smooth sailing! ðŸš€", amount: 0 },
    { text: "Great news! No unexpected expenses this month. You're all set! ðŸ˜Š", amount: 0 },
    { text: "Nothing unusual happened this month. Enjoy your smooth sailing! ðŸš€", amount: 0 },
    { text: "Great news! No unexpected expenses this month. You're all set! ðŸ˜Š", amount: 0 },
    { text: "Nothing unusual happened this month. Enjoy your smooth sailing! ðŸš€", amount: 0 },
    { text: "Surprise family visit - need to stock up on groceries! ðŸ›’", amount: 13000 },
    { text: "Your favorite food vendor increased prices! ðŸ²", amount: 11000 },
    { text: "Water supply issues - need to buy from water truck! ðŸ’§", amount: 16000 },
    { text: "Great news! No unexpected expenses this month. You're all set! ðŸ˜Š", amount: 0 },
    { text: "Nothing unusual happened this month. Enjoy your smooth sailing! ðŸš€", amount: 0 }
];


function revealShock(box, index) {
    if (!box.classList.contains('revealed')) {
        const event = selectedEvents[index];
        box.innerHTML = `
            <div>
                <p>${event.text}</p>
                <div class="shock-amount">-â‚¦${event.amount}</div>
            </div>
        `;
        box.classList.add('revealed');
        shockAmount = event.amount;

        const continueButton = document.getElementById('continueButton');
        continueButton.style.display = 'block';

        if (shockAmount === 0) {
            // For no shock, show "Proceed to Next Stage" button
            alert("No unexpected expense this stage! You can now proceed to the next stage.");
            continueButton.textContent = 'Proceed to Next Stage';
            continueButton.onclick = proceedToNextStage; // Set the correct function for next stage
        } else {
            // For shocks, show "Return to Budget" button
            continueButton.textContent = 'Return to Budget';
            continueButton.onclick = continueGame; // Return to budget adjustments
        }

        // Disable other boxes to prevent multiple clicks
        document.querySelectorAll('.shock-box').forEach(b => {
            b.style.pointerEvents = 'none';
        });
    }
}

function updateAmountDisplays() {
    document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;

    // Include shock amount only in spent calculation, not earnings
    const inputs = document.querySelectorAll('input[type="number"]');
    let spent = shockAmount; // Only reflect shock as a reduction, not in earnings
    inputs.forEach(input => {
        spent += parseInt(input.value) || 0;
    });

    document.getElementById('spent-amount').textContent = `${spent.toLocaleString()} NGN`;
    const remaining = totalAmount - spent;
    document.getElementById('remaining-amount').textContent = `${remaining.toLocaleString()} NGN`;
    document.getElementById('progress').style.width = `${Math.min((spent / totalAmount) * 100, 100)}%`;
}




function saveStageData() {
   const inputs = document.querySelectorAll('input[type="number"]');
   const allocations = {};
  
   inputs.forEach(input => {
       allocations[input.name] = input.value;
   });
  
   stageData[currentStage] = {
       allocations,
       totalAmount,
       shockAmount
   };
  
   localStorage.setItem('stageData', JSON.stringify(stageData));
}






function loadStageData() {
   const savedData = localStorage.getItem('stageData');
   if (savedData) {
       stageData = JSON.parse(savedData);
       const currentStageData = stageData[currentStage];


       if (currentStageData) {
           // Restore shock amount if it exists
           shockAmount = currentStageData.shockAmount || 0;


           // Restore previous inputs
           if (currentStageData.previousInputs) {
               Object.entries(currentStageData.previousInputs).forEach(([name, value]) => {
                   const input = document.querySelector(`input[name="${name}"]`);
                   if (input) input.value = value;
               });
           }


           // Update total amount dynamically for all stages
           const totalAmount = getTotalAmount(currentStage);
           document.getElementById('available-amount').textContent = `${totalAmount.toLocaleString()} NGN`;


           // Update displays dynamically
           updateAmount();
       }
   }
}





clearInterval(timerInterval);
timerInterval = setInterval(() => {
    timeRemaining--;
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    document.getElementById('timer').textContent = 
        `${minutes}:${seconds.toString().padStart(2, '0')}`;
    if (timeRemaining <= 0) {
        clearInterval(timerInterval);
        alert("Time's up! No speed bonus for this round.");
    }
}, 1000);





function resetShockEvent() {
    // Reset the shock boxes
    document.querySelectorAll('.shock-box').forEach(box => {
        box.innerHTML = '<span>?</span>';
        box.classList.remove('revealed');
        box.style.pointerEvents = '';
    });

    // Hide the continue button
    const continueButton = document.getElementById('continueButton');
    if (continueButton) {
        continueButton.style.display = 'none';
    }

    // Hide the shock event UI
    const shockEvent = document.getElementById('shockEvent');
    if (shockEvent) {
        shockEvent.style.display = 'none';
    }

    // Reset shock amount and selected events
    shockAmount = 0;
    selectedEvents = SHOCK_EVENTS.sort(() => 0.5 - Math.random()).slice(0, 3);
}









let db; // Declare the database globally


const request = indexedDB.open("gameDatabase", 1);


request.onupgradeneeded = (event) => {
   db = event.target.result;


   // Create an object store for each stage
   const stages = Object.keys(STAGES);
   stages.forEach(stageName => {
       if (!db.objectStoreNames.contains(stageName)) {
           db.createObjectStore(stageName, { keyPath: "id", autoIncrement: true });
       }
   });
};


request.onsuccess = (event) => {
   db = event.target.result;
   console.log("IndexedDB initialized successfully.");
};


request.onerror = (event) => {
   console.error("IndexedDB error:", event.target.errorCode);
};






// Simple function to send data to the API
function insertStageData(stageName, stageData) {
  console.log('Sending stage data:', stageData);

  return fetch('/api/save-game-data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(stageData),
  })
    .then(async response => {
      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorData}`);
      }
      return response.json();
    })
    .then(data => {
      console.log('Data saved successfully:', data);
      return data;
    })
    .catch(error => {
      console.error('Error saving data:', error);
      throw error;
    });
}
















// function insertStageData(stageName, stageDataToSave) {
//   // First, let's validate the data before sending
//   console.log('Sending data:', {
//     stageName,
//     stageDataToSave
//   });

//   // Construct the payload with default values to ensure all required fields exist
//   const payload = {
//     stageName: stageName || '',
//     totalAmount: stageDataToSave?.totalAmount || 0,
//     shockAmount: stageDataToSave?.shockAmount || 0,
//     totalEarnings: stageDataToSave?.totalEarnings || 0,
//     speedBonus: stageDataToSave?.speedBonus || 0,
//     preShockEarnings: stageDataToSave?.preShockEarnings || 0,
//     amountAllocatedOptions: stageDataToSave?.amountAllocatedOptions || {
//       essentials: {
//         total: 0,
//         options: {}
//       },
//       transport: {
//         total: 0,
//         options: {}
//       },
//       lifestyle: {
//         total: 0,
//         options: {}
//       },
//       savings: {
//         total: 0,
//         options: {}
//       }
//     }
//   };

//   // Log the actual payload being sent
//   console.log('Sending payload:', JSON.stringify(payload, null, 2));

//   return fetch('/api/save-game-data', {
//     method: 'POST',
//     headers: {
//       'Content-Type': 'application/json',
//     },
//     body: JSON.stringify(payload),
//   })
//     .then(async response => {
//       if (!response.ok) {
//         const errorData = await response.json();
//         console.error('Server response:', errorData);
//         throw new Error(
//           errorData?.erroÃŸr || 
//           errorData?.details || 
//           `HTTP error ${response.status}`
//         );
//       }
//       return response.json();
//     })
//     .then(data => {
//       console.log('Data saved successfully:', data);
//       return data;
//     })
//     .catch(error => {
//       console.error('Full error details:', error);
//       throw error;
//     });
// }








function fetchStageData(stageName, callback) {
   const transaction = db.transaction(stageName, "readonly");
   const store = transaction.objectStore(stageName);
   const request = store.getAll();


   request.onsuccess = () => {
       console.log(`Data fetched for ${stageName}:`, request.result);
       callback(request.result);
   };


   request.onerror = (event) => {
       console.error(`Error fetching data from ${stageName}:`, event.target.errorCode);
   };
}




function fetchAllStagesData(stageNames, callback) {
   const allData = [];
   let stagesProcessed = 0;


   stageNames.forEach(stageName => {
       fetchStageData(stageName, (data) => {
           allData.push({ stageName, data });
           stagesProcessed++;


           if (stagesProcessed === stageNames.length) {
               callback(allData);
           }
       });
   });
}




function showStageData(stageName) {
   fetchStageData(stageName, (data) => {
       alert(`Data for ${stageName}: ${JSON.stringify(data, null, 2)}`);
       console.log(`Data for ${stageName}:`, data);
   });
}


function showAllStagesData() {
   const stageNames = Object.keys(STAGES);
   fetchAllStagesData(stageNames, (allData) => {
       alert(`All Stages Data: ${JSON.stringify(allData, null, 2)}`);
       console.log("All Stages Data:", allData);
   });
}




function showAllStagesData() {
   const stageNames = Object.keys(STAGES);
   fetchAllStagesData(stageNames, (allData) => {
       alert(`All Stages Data: ${JSON.stringify(allData, null, 2)}`);
       console.log("All Stages Data:", allData);
   });
}


function clearGameData() {
    const dbName = "gameDatabase";
    const deleteRequest = indexedDB.deleteDatabase(dbName);

    deleteRequest.onsuccess = () => {
        console.log("IndexedDB cleared successfully.");
        alert("Game data cleared!");
    };

    deleteRequest.onerror = (event) => {
        console.error("Error clearing IndexedDB:", event.target.errorCode);
        alert("Failed to clear game data!");
    };

    deleteRequest.onblocked = () => {
        console.warn("Clear operation blocked. Please close other tabs using this site.");
        alert("Clear operation blocked. Close other tabs to retry.");
    };
}



function clearLocalStorage() {
    localStorage.clear();
    console.log("LocalStorage cleared.");
    alert("Local storage cleared!");
}



function clearAllGameData() {
        clearGameData();
        clearLocalStorage();
        alert("All game data has been cleared!");
    }








// Initialize database
function initDB() {
    const request = indexedDB.open("GameDatabase", 2);

    request.onupgradeneeded = (event) => {
        db = event.target.result;
        const stages = ["stage1", "stage2", "stage3"]; // Update with your stages
        
        stages.forEach(stageName => {
            if (!db.objectStoreNames.contains(stageName)) {
                const store = db.createObjectStore(stageName, { keyPath: "id", autoIncrement: true });
                
                // Essential indices
                store.createIndex("date", "date");
                store.createIndex("user_id", "user_id");
                store.createIndex("total_amount", "total_amount");
                store.createIndex("shock_amount", "shock_amount");
                store.createIndex("total_earning", "total_earning");
                store.createIndex("speed_bonus", "speed_bonus");
                store.createIndex("pre_shock_earnings", "pre_shock_earnings");
                store.createIndex("amount_allocated_options", "amount_allocated_options");
            }
        });
    };

    request.onsuccess = (event) => {
        db = event.target.result;
        console.log("Database ready");
    };

    request.onerror = (event) => {
        console.error("Database error:", event.target.error);
    };
}



// Retrieve data for a stage
function getStageData(stageName) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(stageName, "readonly");
        const store = transaction.objectStore(stageName);
        const request = store.getAll();

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}




// async function saveGameData(stageData) {
//     console.log('Attempting to save data:', stageData);
//     try {
//         const response = await axios.post(`${API_BASE_URL}/api/save-game-data`, stageData, {
//             headers: {
//                 'Content-Type': 'application/json',
//                 'Accept': 'application/json'
//             }
//         });
//         console.log('Save successful:', response.data);
//         return response.data;
//     } catch (error) {
//         console.error('Save failed:', error.response?.data || error.message);
//         throw error; // Re-throw to allow further handling
//     }
// }




// async function saveGameData(stageData) {
//     console.log('Attempting to save data:', stageData);
//     const baseUrl = getApiBaseUrl();
    
//     try {
//         const response = await fetch(`${baseUrl}/api/save-game-data`, {
//             method: 'POST',
//             headers: {
//                 'Content-Type': 'application/json',
//                 'Accept': 'application/json'
//             },
//             body: JSON.stringify(stageData)
//         });

//         if (!response.ok) {
//             throw new Error(`HTTP error! status: ${response.status}`);
//         }

//         const data = await response.json();
//         console.log('Save successful:', data);
//         return data;
//     } catch (error) {
//         console.error('Save failed:', error.message);
//         throw error; // Re-throw to allow further handling
//     }
// }



// function saveGameData(data) {
//     return new Promise((resolve, reject) => {
//         try {
//             // Simulate saving to local storage or API
//             if (window.location.hostname === 'localhost') {
//                 localStorage.setItem('gameData', JSON.stringify(data));
//                 console.log('Data saved locally:', data);
//                 resolve({ status: 'success', message: 'Saved locally' });
//             } else {
//                 const apiBaseUrl = getApiBaseUrl();
//                 axios.post(`${apiBaseUrl}/api/saveGameData`, data)
//                     .then(response => resolve(response.data))
//                     .catch(error => reject(error));
//             }
//         } catch (error) {
//             reject(error);
//         }
//     });
// }


      
      
function saveGameData(data, isPostShock = false) {
    return new Promise((resolve, reject) => {
        try {
            // Create dataToSave object with the additional 'dataType' field
            const dataToSave = {
                ...data,
                dataType: isPostShock ? "post-shock" : "pre-shock"
            };

            // If running locally, save the data in localStorage
            if (window.location.hostname === 'localhost') {
                localStorage.setItem('gameData', JSON.stringify(dataToSave));
                console.log('Data saved locally:', dataToSave);
                resolve({ status: 'success', message: 'Saved locally' });
            } else {
                // For non-localhost, send data via API request
                const apiBaseUrl = getApiBaseUrl();
                axios.post(`${apiBaseUrl}/api/save-game-data`, dataToSave) // Use backticks for template literals
                    .then(response => resolve(response.data))
                    .catch(error => reject(error));
            }
        } catch (error) {
            // Handle any unexpected errors
            reject(error);
        }
    });
}

      


    </script>
</body>
</html>